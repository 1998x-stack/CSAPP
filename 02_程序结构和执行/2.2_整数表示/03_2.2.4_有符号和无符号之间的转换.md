# 03_2.2.4_有符号和无符号之间的转换

"""
Lecture: 02_程序结构和执行/2.2_整数表示
Content: 03_2.2.4_有符号和无符号之间的转换
"""

### 2.2.4 有符号和无符号之间的转换

#### 简介
在C语言中，有时需要在有符号整数和无符号整数之间进行转换。这种转换可以通过显式类型转换（casting）或隐式类型转换实现。转换的效果通常依赖于底层的位级表示，而不是直接数值上的解释。这部分将详细探讨有符号和无符号整数之间的转换机制及其影响。

#### 显式类型转换

1. **有符号转换为无符号**：
   当将一个有符号整数转换为无符号整数时，位模式保持不变，但解释方式改变。例如，假设有一个`short`类型的变量`v`，值为-12345，将其转换为`unsigned short`类型时，输出如下：
   ```c
   short v = -12345;
   unsigned short uv = (unsigned short)v;
   printf("v = %d, uv = %u\n", v, uv);
   ```
   结果：
   ```
   v = -12345, uv = 53191
   ```
   这里，-12345的16位补码表示与53191的16位无符号表示相同，只是解释方式不同。

2. **无符号转换为有符号**：
   当将一个无符号整数转换为有符号整数时，位模式同样保持不变。例如：
   ```c
   unsigned u = 4294967295u; // UMax
   int tu = (int)u;
   printf("u = %u, tu = %d\n", u, tu);
   ```
   结果：
   ```
   u = 4294967295, tu = -1
   ```
   对于32位字长，4294967295（UMax）的位模式与-1的补码表示相同。

#### 隐式类型转换

1. **赋值操作**：
   当将一个类型的值赋给另一个类型的变量时，如果类型不同，会发生隐式转换。例如：
   ```c
   int tx;
   unsigned ux = 10;
   tx = ux; // 隐式转换为有符号整数
   printf("tx = %d\n", tx);
   ```

2. **表达式中的转换**：
   在表达式中，如果操作数类型不同，C语言会进行隐式转换。例如：
   ```c
   int x = -1;
   unsigned y = 1;
   printf("%u\n", x + y); // -1隐式转换为无符号整数
   ```

#### 转换规则

1. **T2Uw**函数（有符号到无符号的转换）：
   对于一个有符号整数x，如果其位于范围$$TMinw, TMaxw$$内，则有：
   - 如果x < 0，则T2Uw(x) = x + 2^w
   - 否则，T2Uw(x) = x
   例如，T2U16(-12345) = 53191。

2. **U2Tw**函数（无符号到有符号的转换）：
   对于一个无符号整数u，如果其位于范围$$0, UMaxw$$内，则有：
   - 如果u > TMaxw，则U2Tw(u) = u - 2^w
   - 否则，U2Tw(u) = u
   例如，U2T32(4294967295) = -1。

#### 转换影响

1. **算术操作的影响**：
   在包含有符号和无符号操作数的表达式中，操作数会被隐式转换为无符号类型，可能导致非预期的结果。例如：
   ```c
   int a = -1;
   unsigned b = 2;
   printf("%d\n", a < b); // 输出0，因为-1被转换为无符号数
   ```

2. **比较操作的影响**：
   当比较操作的操作数类型不同时，会进行隐式转换，导致比较结果可能与预期不符。例如：
   ```c
   int x = -1;
   unsigned y = 0;
   printf("%d\n", x < y); // 输出0，因为-1被转换为无符号数，实际比较的是4294967295 < 0
   ```

#### 结论

有符号和无符号之间的转换在C语言中是一个常见的操作，但需要注意的是，这种转换通常依赖于底层的位级表示，而不是数值上的直接解释。理解这些转换规则及其影响，对于编写正确和高效的代码至关重要。通过显式和隐式转换的机制，可以更好地控制和预期程序的行为，避免潜在的错误和漏洞。