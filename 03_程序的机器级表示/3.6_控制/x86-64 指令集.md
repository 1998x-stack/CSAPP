在计算机科学中，指令（Instructions）是计算机处理器执行的基本操作。x86-64 架构的指令集包括多种类型的指令，每种指令都有特定的功能和操作方式。以下是关于 x86-64 指令集的详细表格，涵盖了算术指令、逻辑指令、数据传输指令、控制指令、栈操作指令和位操作指令等。

### x86-64 指令集详细表格

| 指令类型     | 指令    | 操作数         | 说明                                                         | 示例                                    |
|-------------|---------|---------------|--------------------------------------------------------------|-----------------------------------------|
| 算术指令    | `add`   | 2             | 将两个操作数相加，结果存储在目的操作数中                      | `add %rbx, %rax`                        |
|             | `sub`   | 2             | 将源操作数从目的操作数中减去，结果存储在目的操作数中          | `sub %rcx, %rdx`                        |
|             | `imul`  | 2/3           | 乘法运算，支持有符号乘法                                      | `imul %rsi, %rdi`                       |
|             | `div`   | 1             | 无符号除法                                                   | `div %rcx`                              |
|             | `idiv`  | 1             | 有符号除法                                                   | `idiv %rbx`                             |
|             | `inc`   | 1             | 将操作数加1                                                  | `inc %rax`                              |
|             | `dec`   | 1             | 将操作数减1                                                  | `dec %rdx`                              |
|             | `neg`   | 1             | 取负操作                                                     | `neg %rbx`                              |
| 逻辑指令    | `and`   | 2             | 按位与操作                                                   | `and %rsi, %rax`                        |
|             | `or`    | 2             | 按位或操作                                                   | `or %rdx, %rcx`                         |
|             | `xor`   | 2             | 按位异或操作                                                 | `xor %rbx, %rdi`                        |
|             | `not`   | 1             | 按位取反操作                                                 | `not %rax`                              |
| 数据传输指令| `mov`   | 2             | 将源操作数的数据传输到目的操作数                              | `mov %rsi, %rdx`                        |
|             | `movzx` | 2             | 将源操作数的值零扩展并传输到目的操作数                        | `movzx %ax, %ebx`                       |
|             | `movsx` | 2             | 将源操作数的值符号扩展并传输到目的操作数                      | `movsx %al, %ebx`                       |
|             | `lea`   | 2             | 加载有效地址                                                 | `lea 8(%rbx), %rax`                     |
| 控制指令    | `jmp`   | 1             | 无条件跳转                                                   | `jmp .L1`                               |
|             | `je`    | 1             | 如果等于（ZF=1），则跳转                                      | `je .L2`                                |
|             | `jne`   | 1             | 如果不等于（ZF=0），则跳转                                    | `jne .L3`                               |
|             | `jg`    | 1             | 如果大于（ZF=0 且 SF=OF），则跳转                             | `jg .L4`                                |
|             | `jl`    | 1             | 如果小于（SF≠OF），则跳转                                     | `jl .L5`                                |
|             | `jge`   | 1             | 如果大于等于（SF=OF），则跳转                                 | `jge .L6`                               |
|             | `jle`   | 1             | 如果小于等于（ZF=1 或 SF≠OF），则跳转                         | `jle .L7`                               |
|             | `call`  | 1             | 调用子程序                                                   | `call printf`                           |
|             | `ret`   | 0             | 返回到调用点                                                 | `ret`                                   |
| 栈操作指令  | `push`  | 1             | 将操作数推入栈                                               | `push %rax`                             |
|             | `pop`   | 1             | 从栈中弹出操作数                                             | `pop %rbx`                              |
|             | `pushf` | 0             | 将标志寄存器的值推入栈                                       | `pushf`                                 |
|             | `popf`  | 0             | 从栈中弹出标志寄存器的值                                     | `popf`                                  |
| 位操作指令  | `shl`   | 2             | 左移操作数，右边补0                                          | `shl $2, %rax`                          |
|             | `shr`   | 2             | 逻辑右移操作数，左边补0                                      | `shr $1, %rbx`                          |
|             | `sar`   | 2             | 算术右移操作数，左边补符号位                                  | `sar $1, %rcx`                          |
|             | `rol`   | 2             | 循环左移                                                     | `rol $1, %rdx`                          |
|             | `ror`   | 2             | 循环右移                                                     | `ror $1, %rsi`                          |
| 条件移动指令| `cmove` | 2             | 如果等于（ZF=1），则移动                                      | `cmove %rbx, %rax`                      |
|             | `cmovne`| 2             | 如果不等于（ZF=0），则移动                                    | `cmovne %rcx, %rdx`                     |
|             | `cmovg` | 2             | 如果大于（ZF=0 且 SF=OF），则移动                             | `cmovg %rdi, %rbx`                      |
|             | `cmovl` | 2             | 如果小于（SF≠OF），则移动                                     | `cmovl %rsi, %rcx`                      |

### 说明

- **算术指令** 用于执行基本的数学操作，如加法、减法、乘法和除法。
- **逻辑指令** 用于执行按位操作，如与、或、异或和非。
- **数据传输指令** 用于在寄存器和内存之间传输数据。
- **控制指令** 用于控制程序流程，包括条件跳转和子程序调用。
- **栈操作指令** 用于管理栈数据结构，包括推入和弹出操作。
- **位操作指令** 用于执行位移和旋转操作。
- **条件移动指令** 根据条件码的状态有选择地移动数据。
