# 04_3.8.5_可变大小数组

"""
Lecture: 03_程序的机器级表示/3.8_数组分配和访问
Content: 04_3.8.5_可变大小数组
"""

## 3.8.5 可变大小数组

### 章节概述
在《深入理解计算机系统》第3章“程序的机器级表示”中，第3.8.5节探讨了可变大小数组的基本原理。历史上，C语言仅支持多维数组，这些数组的大小（除第一维外）在编译时必须确定。然而，ISO C99引入了可变大小数组的功能，使得数组维度可以在数组分配时计算。本节内容主要涵盖了可变大小数组的定义、内存布局及其在x86-64架构下的实现和优化。

### 可变大小数组的定义
在C语言中，可变大小数组可以声明为局部变量或函数参数。例如：
```c
int A[expr1][expr2];
```
其中，`expr1`和`expr2`是在声明时计算的表达式。例如，我们可以编写一个函数来访问一个n×n数组的元素`A[i][j]`：
```c
int var_ele(long n, int A[n][n], long i, long j) {
    return A[i][j];
}
```
注意，这里参数`n`必须在参数`A[n][n]`之前声明，以便在遇到数组参数时计算数组维度。

### 内存布局
可变大小数组在内存中的布局与固定大小数组类似，也是按行优先（row-major order）排列的。不同之处在于数组的维度在运行时计算。例如，对于数组`A[n][n]`，元素`A[i][j]`的地址计算公式为：
```plaintext
&A[i][j] = xA + L * (n * i + j)
```
其中，`xA`是数组`A`的起始地址，`L`是元素类型的大小（以字节为单位），`n`是数组的列数，`i`和`j`分别是行和列的索引。

### 元素访问的地址计算
以二维数组`T D[R][C]`为例，元素`D[i][j]`的地址计算公式为：
```plaintext
&D[i][j] = xD + L * (C * i + j)
```
在x86-64架构下，访问可变大小数组的元素时，需要计算目标元素的偏移量，并使用数组起始地址和偏移量来访问内存。例如，对于函数`var_ele`，其汇编代码如下：
```assembly
1 var_ele:
2     imulq %rdx, %rdi       # 计算 n * i
3     leaq (%rsi,%rdi,4), %rax  # 计算 xA + 4 * (n * i)
4     movl (%rax,%rcx,4), %eax  # 读取 M[xA + 4 * (n * i) + 4 * j]
5     ret
```
这段代码通过乘法和加法计算地址`xA + 4 * (n * i + j)`，并使用该地址访问内存中的数据。

### 优化策略
可变大小数组的灵活性使其在某些场景下优于固定大小数组。然而，这种灵活性也带来了性能上的挑战，特别是地址计算中的乘法操作。在某些处理器中，乘法操作可能会带来显著的性能开销。因此，理解和优化可变大小数组的访问方式对提高程序性能至关重要。

#### 示例：矩阵乘法的优化
以下是一个矩阵乘法的优化示例，展示了如何利用可变大小数组的灵活性进行优化：
```c
int var_prod_ele(long n, int A[n][n], int B[n][n], long i, long k) {
    int *Arow = A[i];
    int *Bptr = &B[0][k];
    int result = 0;
    for (long j = 0; j < n; j++) {
        result += Arow[j] * *Bptr;
        Bptr += n;
    }
    return result;
}
```
通过使用指针遍历数组元素，避免了多次乘法操作，从而提高了性能。

### 应用场景
可变大小数组在需要动态分配内存的场景中非常有用，特别是当数组大小在编译时未知时。例如，在处理矩阵计算、图像处理和动态数据结构（如动态二维数组）时，可变大小数组提供了极大的灵活性和便利性。

### 总结
本节详细讨论了可变大小数组的定义、内存布局和访问方式。在x86-64架构下，可变大小数组的访问通过基址加索引和乘法的方式实现，支持灵活的内存地址计算。理解这些基本原理并应用合适的优化策略，有助于编写高效且灵活的数组操作代码。
