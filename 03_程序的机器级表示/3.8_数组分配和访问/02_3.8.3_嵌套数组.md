# 02_3.8.3_嵌套数组

"""
Lecture: 03_程序的机器级表示/3.8_数组分配和访问
Content: 02_3.8.3_嵌套数组
"""

## 3.8.3 嵌套数组

### 章节概述
在《深入理解计算机系统》第3章“程序的机器级表示”中，第3.8.3节探讨了嵌套数组的基本原理。嵌套数组，也称多维数组，是数组的元素本身也是数组。这一节详细分析了嵌套数组的定义、内存布局及在x86-64架构下的访问方式。

### 嵌套数组的定义
在C语言中，嵌套数组可以定义为多维数组。例如，以下代码定义了一个包含5行3列的二维整型数组：
```c
int A[5][3];
```
这意味着数组`A`包含5个元素，每个元素又是一个包含3个`int`类型元素的数组。等价地，可以使用类型定义：
```c
typedef int row3_t[3];
row3_t A[5];
```
这里，`row3_t`被定义为一个包含3个`int`类型元素的数组，而`A`是包含5个`row3_t`类型元素的数组。

### 内存布局
嵌套数组在内存中是按行优先（row-major order）排列的。这意味着，数组的所有行依次存储，每行的元素紧挨着前一行的元素。例如，对于数组`A[5][3]`，内存布局如下：

| 元素    | 地址偏移量   |
|--------|------------|
| A[0][0]| xA         |
| A[0][1]| xA + 4     |
| A[0][2]| xA + 8     |
| A[1][0]| xA + 12    |
| A[1][1]| xA + 16    |
| A[1][2]| xA + 20    |
| A[2][0]| xA + 24    |
| A[2][1]| xA + 28    |
| A[2][2]| xA + 32    |
| A[3][0]| xA + 36    |
| A[3][1]| xA + 40    |
| A[3][2]| xA + 44    |
| A[4][0]| xA + 48    |
| A[4][1]| xA + 52    |
| A[4][2]| xA + 56    |

### 元素访问的地址计算
为了访问嵌套数组的元素，编译器生成的代码会计算目标元素的偏移量，并使用数组起始地址和偏移量来访问内存。例如，对于二维数组`T D[R][C]`，元素`D[i][j]`的地址计算公式为：
```plaintext
&D[i][j] = xD + L * (C * i + j)
```
其中，`xD`是数组`D`的起始地址，`L`是元素类型的大小（以字节为单位），`C`是数组的列数，`i`和`j`分别是行和列的索引。

### 示例分析
假设有以下二维数组定义：
```c
int A[5][3];
```
此数组占用连续的内存块，每个元素的大小为4个字节（`int`类型）。若`xA`、`i`和`j`分别存储在寄存器`%rdi`、`%rsi`和`%rdx`中，那么要访问元素`A[i][j]`，可以使用以下指令：
```assembly
1  leaq  (%rsi,%rsi,2), %rax  # 计算 3*i
2  leaq  (%rdi,%rax,4), %rax  # 计算 xA + 12*i
3  movl  (%rax,%rdx,4), %eax  # 读取 M[xA + 12*i + 4*j]
```
这段代码通过缩放和加法计算地址`xA + 12*i + 4*j`，并使用该地址访问内存中的数据。

### 内存对齐
为了提高内存访问的效率，编译器和处理器通常会对内存进行对齐。对齐意味着数据的起始地址是某个字节边界的倍数。对于嵌套数组中的每个元素，其地址必须对齐到元素类型大小的整数倍。例如，一个`int`类型数组的元素地址应该是4的倍数。

### 多维数组的访问方式
在C语言中，访问多维数组的元素可以使用多个下标。例如，`A[i][j]`表示数组`A`中第`i`行第`j`列的元素。其内存地址计算公式为：
```plaintext
&A[i][j] = xA + (i * 列数 + j) * sizeof(元素类型)
```
具体到`A[5][3]`，`A[i][j]`的内存地址为`xA + (i * 3 + j) * 4`。

### 应用场景
嵌套数组在实际编程中非常常见，特别是在处理矩阵或多维数据时。例如，图像处理中的二维像素矩阵、科学计算中的多维数据集等，都会用到嵌套数组。

#### 示例：矩阵乘法
矩阵乘法是嵌套数组的典型应用。假设有两个矩阵`A`和`B`，其元素分别存储在二维数组中，矩阵乘法可以通过嵌套循环实现：
```c
for (i = 0; i < 行数A; i++) {
    for (j = 0; j < 列数B; j++) {
        C[i][j] = 0;
        for (k = 0; k < 列数A; k++) {
            C[i][j] += A[i][k] * B[k][j];
        }
    }
}
```
这种嵌套循环结构反映了嵌套数组的存取方式，内层循环遍历矩阵的每一行和每一列。

### 优化策略
由于嵌套数组的访问涉及多次内存读取和写入，优化这些操作可以显著提高程序的性能。常见的优化策略包括：
1. **提高缓存命中率**：调整数组访问顺序，使得连续访问的元素尽量存储在相邻的内存位置。
2. **避免缓存行冲突**：确保不同数组或数组不同部分不频繁地映射到相同的缓存行。
3. **使用块划分**：将大数组划分为多个小块，每次处理一个块，从而减少缓存缺失。

### 总结
本节详细讨论了嵌套数组的定义、内存布局和访问方式。在x86-64架构下，嵌套数组的访问通过基址加索引的方式实现，支持高效的地址计算和内存访问。理解这些基本原理有助于编写高效且正确的嵌套数组操作代码，并通过优化策略进一步提高程序性能。