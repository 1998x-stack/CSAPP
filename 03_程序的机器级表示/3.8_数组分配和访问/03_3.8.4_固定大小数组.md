# 03_3.8.4_固定大小数组

"""
Lecture: 03_程序的机器级表示/3.8_数组分配和访问
Content: 03_3.8.4_固定大小数组
"""

## 3.8.4 固定大小数组

### 章节概述
在《深入理解计算机系统》第3章“程序的机器级表示”中，第3.8.4节讨论了固定大小数组的基本原理。固定大小数组是一种在编译时就确定大小的多维数组，这种数组允许编译器进行各种优化，从而提高代码的运行效率。本节主要探讨了固定大小数组的定义、内存布局及其在x86-64架构下的实现和优化。

### 固定大小数组的定义
在C语言中，可以使用宏定义（`#define`）和类型定义（`typedef`）来定义固定大小数组。例如，定义一个16x16的整型矩阵：
```c
#define N 16
typedef int fix_matrix[N][N];
```
这种定义方式不仅使代码更加简洁明了，还方便在需要修改数组大小时，只需更改宏定义的值即可。

### 固定大小数组的内存布局
固定大小数组在内存中是按行优先（row-major order）排列的，这意味着数组的所有行依次存储，每行的元素紧挨着前一行的元素。例如，对于`fix_matrix`类型的数组`A`，其内存布局如下：

| 元素     | 地址偏移量  |
|----------|------------|
| A[0][0]  | xA         |
| A[0][1]  | xA + 4     |
| A[0][2]  | xA + 8     |
| ...      | ...        |
| A[0][15] | xA + 60    |
| A[1][0]  | xA + 64    |
| ...      | ...        |
| A[15][15]| xA + 1020  |

### 元素访问的地址计算
为了访问固定大小数组的元素，编译器生成的代码会计算目标元素的偏移量，并使用数组起始地址和偏移量来访问内存。例如，对于`fix_matrix`类型的二维数组`A`，元素`A[i][j]`的地址计算公式为：
```plaintext
&A[i][j] = xA + L * (N * i + j)
```
其中，`xA`是数组`A`的起始地址，`L`是元素类型的大小（以字节为单位），`N`是数组的列数，`i`和`j`分别是行和列的索引。

### 示例分析
假设有以下固定大小数组定义：
```c
#define N 16
typedef int fix_matrix[N][N];
fix_matrix A;
```
若`xA`、`i`和`j`分别存储在寄存器`%rdi`、`%rsi`和`%rdx`中，那么要访问元素`A[i][j]`，可以使用以下指令：
```assembly
1  leaq  (%rsi,%rsi,4), %rax  # 计算 4*i
2  leaq  (%rdi,%rax,4), %rax  # 计算 xA + 16*i
3  movl  (%rax,%rdx,4), %eax  # 读取 M[xA + 16*i + 4*j]
```
这段代码通过缩放和加法计算地址`xA + 16*i + 4*j`，并使用该地址访问内存中的数据。

### 优化策略
固定大小数组的特点使得编译器可以进行多种优化，从而提高代码的运行效率。以下是一些常见的优化策略：

1. **消除索引变量**：编译器可以将数组引用转换为指针运算，避免使用索引变量。例如，使用指针遍历数组元素可以减少循环开销。
2. **循环展开**：对于固定大小的数组，编译器可以展开循环，减少循环控制的开销，提高流水线效率。
3. **预取（Prefetching）**：编译器可以生成预取指令，将即将使用的数据提前加载到缓存中，减少内存访问延迟。

#### 示例：矩阵乘法的优化
以下是一个矩阵乘法的优化示例，展示了如何利用固定大小数组的特点进行优化：
```c
#define N 16
typedef int fix_matrix[N][N];

int fix_prod_ele(fix_matrix A, fix_matrix B, long i, long k) {
    long j;
    int result = 0;
    for (j = 0; j < N; j++)
        result += A[i][j] * B[j][k];
    return result;
}
```
优化后的代码通过使用指针运算和循环展开，可以显著提高性能。

### 总结
固定大小数组在编译时确定大小，允许编译器进行各种优化，显著提高了代码的运行效率。理解固定大小数组的内存布局和访问方式，有助于编写高效的数组操作代码，并通过合理的优化策略进一步提升程序性能。