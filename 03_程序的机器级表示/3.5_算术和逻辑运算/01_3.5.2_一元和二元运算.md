# 01_3.5.2_一元和二元运算

"""
Lecture: 03_程序的机器级表示/3.5_算术和逻辑运算
Content: 01_3.5.2_一元和二元运算
"""

### 3.5.2 一元和二元运算

在计算机程序的机器级表示中，一元和二元运算是基本的算术和逻辑操作。它们在处理数据时发挥着关键作用，并且它们的操作数和运算结果直接影响寄存器或内存位置的状态。以下是对这一章节的详细分析。

#### 一元运算

一元运算是指只需一个操作数的运算，这个操作数既是源操作数，也是目的操作数。这种运算可以作用于寄存器或内存位置。例如：
- `incq (%rsp)`：将栈顶元素递增1。

一元运算的常见类型及其作用如下：
1. **递增 (inc)**：对操作数加1。
   - 例如：`incq %rax` 对 `%rax` 寄存器的值加1。
2. **递减 (dec)**：对操作数减1。
   - 例如：`decq %rbx` 对 `%rbx` 寄存器的值减1。
3. **取反 (neg)**：对操作数取负。
   - 例如：`negq %rcx` 对 `%rcx` 寄存器的值取负值。
4. **按位取反 (not)**：对操作数的每一位进行取反。
   - 例如：`notq %rdx` 对 `%rdx` 寄存器的每一位进行取反操作。

这些一元运算在汇编代码中使用频繁，能够高效地完成基本的数据操作。

#### 二元运算

二元运算是指需要两个操作数的运算，其中一个操作数既是源操作数，也是目的操作数。这种运算的语法类似于C语言中的赋值运算符，例如 `x -= y`。但需要注意的是，在汇编中，源操作数在前，目的操作数在后，这对于非交换律操作可能会显得不直观。例如：
- `subq %rax, %rdx`：将 `%rax` 的值从 `%rdx` 中减去（即 `%rdx = %rdx - %rax`）。

常见的二元运算包括：
1. **加法 (add)**：对两个操作数进行加法运算。
   - 例如：`addq %rax, %rbx` 对 `%rax` 和 `%rbx` 的值进行加法运算，结果存储在 `%rbx` 中。
2. **减法 (sub)**：对两个操作数进行减法运算。
   - 例如：`subq %rcx, %rdx` 对 `%rdx` 和 `%rcx` 的值进行减法运算，结果存储在 `%rdx` 中。
3. **乘法 (imul)**：对两个操作数进行乘法运算。
   - 例如：`imulq %rsi, %rdi` 对 `%rsi` 和 `%rdi` 的值进行乘法运算，结果存储在 `%rdi` 中。
4. **异或 (xor)**：对两个操作数进行按位异或运算。
   - 例如：`xorq %r8, %r9` 对 `%r8` 和 `%r9` 的值进行按位异或运算，结果存储在 `%r9` 中。
5. **或 (or)**：对两个操作数进行按位或运算。
   - 例如：`orq %r10, %r11` 对 `%r10` 和 `%r11` 的值进行按位或运算，结果存储在 `%r11` 中。
6. **与 (and)**：对两个操作数进行按位与运算。
   - 例如：`andq %r12, %r13` 对 `%r12` 和 `%r13` 的值进行按位与运算，结果存储在 `%r13` 中。

二元运算的第一个操作数可以是立即数、寄存器或内存位置，而第二个操作数可以是寄存器或内存位置。需要注意的是，两个操作数不能同时是内存位置。当第二个操作数是内存位置时，处理器必须先从内存中读取值，执行运算，然后将结果写回内存。

#### 实践例题

假设在以下内存地址和寄存器中存储了如下值：

| 地址      | 值    | 寄存器 | 值   |
| -------- | ----- | ------ | ---- |
| 0x100    | 0xFF  | %rax   | 0x100|
| 0x108    | 0xAB  | %rcx   | 0x1  |
| 0x110    | 0x13  | %rdx   | 0x3  |
| 0x118    | 0x11  |        |      |

以下指令的执行结果如下表所示：

| 指令                   | 目的地           | 结果       |
| --------------------- | --------------- | ---------- |
| addq %rcx,(%rax)      | 0x100           | 0x100 + 0x1= 0x101 |
| subq %rdx,8(%rax)     | 0x108           | 0xAB - 0x3 = 0xA8 |
| imulq $16,(%rax,%rdx,8)| 0x110           | 0x13 * 16 = 0x130|
| incq 16(%rax)         | 0x118           | 0x11 + 1 = 0x12 |
| decq %rcx             | %rcx            | 0x1 - 1 = 0x0 |
| subq %rdx,%rax        | %rax            | 0x100 - 0x3 = 0xFD|

这些示例展示了二元运算的实际效果和内存或寄存器状态的变化。

### 总结

一元和二元运算是机器级程序中最基础的操作，它们的高效实现对程序的性能至关重要。理解这些指令的操作方式和使用场景，有助于深入掌握计算机底层运算的原理和优化程序性能   。