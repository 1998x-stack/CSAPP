# 00_3.9.1_结构体

"""
Lecture: 03_程序的机器级表示/3.9_异质数据结构
Content: 00_3.9.1_结构体
"""

## 3.9.1 结构体

### 章节概述
在《深入理解计算机系统》第3章“程序的机器级表示”中，第3.9.1节讨论了结构体的基本原理。结构体是C语言中一种重要的数据类型，允许将不同类型的对象组合成一个单一的对象。结构体的实现类似于数组，即所有的结构体成员存储在一块连续的内存区域中，结构体的指针指向其第一个字节。

### 结构体的定义
在C语言中，可以使用`struct`关键字来定义结构体。例如，下面的代码定义了一个名为`rec`的结构体：
```c
struct rec {
    int i;
    int j;
    int a[2];
    int *p;
};
```
该结构体包含四个字段：两个4字节的`int`类型字段，一个包含两个`int`类型元素的数组，以及一个8字节的整数指针，总共占用24字节的内存。

### 内存布局
结构体的所有成员存储在一块连续的内存区域中，每个成员的内存地址相对于结构体起始地址的偏移量是固定的。例如，考虑以下结构体：
```c
struct rec {
    int i;
    int j;
    int a[2];
    int *p;
};
```
其内存布局如下：

| 偏移量   | 内容     |
|--------|--------|
| 0      | i      |
| 4      | j      |
| 8      | a[0]   |
| 12     | a[1]   |
| 16     | p      |

在这个例子中，数组`a`嵌入在结构体中，其元素的偏移量相对于结构体起始地址依次为8和12。

### 访问结构体成员
为了访问结构体的成员，编译器生成的代码会将结构体的起始地址与成员的偏移量相加。例如，假设变量`r`是`struct rec`类型的结构体，其地址存储在寄存器`%rdi`中，以下汇编代码将`r->i`的值复制到寄存器`%eax`中，并将`r->j`的值复制到内存中：
```assembly
movl (%rdi), %eax      # 获取r->i的值
movl %eax, 4(%rdi)     # 将值存储到r->j中
```
由于`i`的偏移量为0，访问`r->i`时直接使用`r`的地址。为了访问`j`，需要将`r`的地址加上偏移量4。

### 生成指向结构体成员的指针
通过将字段的偏移量与结构体地址相加，可以生成指向结构体成员的指针。例如，生成指针`&(r->a[1])`的汇编代码如下：
```assembly
leaq 12(%rdi), %rax     # 生成指针&(r->a[1])
```
假设`r`在寄存器`%rdi`中，计算`&(r->a[i])`的地址，可以使用以下指令：
```assembly
leaq 8(%rdi,%rsi,4), %rax   # 计算&r->a[i]
```
其中，`r`在寄存器`%rdi`中，`i`在寄存器`%rsi`中。

### 结构体在函数中的使用
结构体在函数中常常以指针的形式传递，以避免复制整个结构体。例如，以下函数计算矩形的面积，参数是一个指向矩形结构体的指针：
```c
long area(struct rect *rp) {
    return rp->width * rp->height;
}
```
表达式`rp->width`通过指针解引用并选择结构体的`width`字段。为了方便，这种组合操作可以简写为`rp->width`，等价于`(*rp).width`。

### 优化和对齐
为了提高访问效率，编译器会在结构体成员之间插入填充字节，以确保每个成员都满足其对齐要求。例如，以下结构体定义：
```c
struct S1 {
    int i;
    char c;
    int j;
};
```
编译器会插入3个字节的填充，使得`j`的地址对齐到4的倍数，从而提高访问效率：

| 偏移量   | 内容     |
|--------|--------|
| 0      | i      |
| 4      | c      |
| 8      | 填充   |
| 12     | j      |

### 实际应用
结构体广泛用于需要将多个不同类型的数据组合在一起的场景，如定义复合数据类型、实现数据结构（如链表、树等）以及描述复杂的实体对象（如矩形、图形等）。

### 总结
本节详细讨论了结构体的定义、内存布局和访问方式。结构体允许将不同类型的对象组合成一个单一对象，所有成员存储在一块连续的内存区域中。理解结构体的内存布局和访问机制，有助于编写高效的代码，并通过合理的对齐和优化策略进一步提升程序性能。

