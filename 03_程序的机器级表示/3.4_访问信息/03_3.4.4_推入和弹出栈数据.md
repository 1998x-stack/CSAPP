# 03_3.4.4_推入和弹出栈数据

"""
Lecture: 03_程序的机器级表示/3.4_访问信息
Content: 03_3.4.4_推入和弹出栈数据
"""

### 3.4.4 推入和弹出栈数据

在程序的机器级表示中，推入和弹出栈数据是基本的栈操作，这些操作在处理过程调用时起着至关重要的作用。栈是一种数据结构，遵循“后进先出”的原则，这意味着最新加入栈的数据最先被移出。我们使用 `push` 操作将数据推入栈中，使用 `pop` 操作从栈中弹出数据。

#### 栈的基本操作

栈操作包括 `pushq` 和 `popq`，它们分别用于将数据推入栈和从栈中弹出数据。每个操作只有一个操作数：`pushq` 的数据源和 `popq` 的数据目的地。

- `pushq S` 操作：
  1. 将栈指针寄存器 `%rsp` 减少 8，腾出空间。
  2. 将操作数 `S` 的值存储在新的栈顶地址中。

- `popq D` 操作：
  1. 将栈顶的数据值读入目的寄存器 `D`。
  2. 将栈指针寄存器 `%rsp` 增加 8，移出栈顶。

这些操作的效果可以通过以下伪代码展示：
- `pushq %rbp` 等价于：
  ```assembly
  subq $8, %rsp    ; 栈指针减小8
  movq %rbp, (%rsp) ; 将 %rbp 的值存入栈顶
  ```
- `popq %rax` 等价于：
  ```assembly
  movq (%rsp), %rax ; 将栈顶的数据读入 %rax
  addq $8, %rsp    ; 栈指针增加8
  ```

#### 栈的增长方向

在 x86-64 架构中，栈在内存中的增长方向是向下的，也就是说，栈顶的元素地址是所有栈元素中最低的。栈指针寄存器 `%rsp` 保存当前栈顶元素的地址。

栈的增长和缩小涉及栈指针的操作。例如，当执行 `pushq %rax` 指令时，若 `%rsp` 初始值为 `0x108`，且 `%rax` 的值为 `0x123`，操作后：
- `%rsp` 将减少 8，变为 `0x100`。
- `0x123` 将被存储在内存地址 `0x100` 处。

当随后执行 `popq %rdx` 指令时，操作如下：
- 内存地址 `0x100` 处的值 `0x123` 被读入寄存器 `%rdx`。
- `%rsp` 增加 8，恢复到 `0x108`。

#### 栈帧和过程调用

在过程调用中，栈用于存储返回地址、局部变量和保存的寄存器值。每个过程调用会在栈上创建一个新的栈帧。当前执行的过程的栈帧总是在栈顶。当一个过程调用另一个过程时，调用者会将返回地址推入栈中，以便被调用过程返回后能继续执行。

栈帧结构的例子可以参考函数 `vframe`，其栈帧中包括局部变量、保存的寄存器以及动态分配的数组等：
- 保存旧的帧指针 `%rbp`。
- 使用新的 `%rbp` 作为当前栈帧的基址。
- 根据需要分配局部变量和数组的空间。

栈操作不仅用于数据存储和过程调用，还用于保持程序的控制流和数据一致性。这些操作通过简单且高效的方式管理内存和寄存器，为复杂程序提供了必要的基础设施。

#### 栈操作的编码效率

`pushq` 和 `popq` 指令在机器码中的编码比对应的 `subq` 和 `movq` 指令对更加紧凑。例如：
- `pushq %rbp` 只需一个字节编码，而 `subq $8, %rsp` 和 `movq %rbp, (%rsp)` 两条指令共需 8 个字节。

总结来说，推入和弹出栈数据的操作是现代计算机程序中不可或缺的一部分，理解这些操作有助于更深入地掌握程序的机器级表示和优化程序的性能 。